// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.ComponentModel.DataAnnotations;
using System.Diagnostics;
using System.Linq;
using System.Threading.Tasks;
using McMaster.Extensions.CommandLineUtils;

namespace EGBench
{
    public partial class CLI
    {
        [Command(Name = "publisher", Description = "Generate load against an eventgrid endpoint.")]
        [Subcommand(typeof(StartPublishCommand))]
        public class PublisherCLI
        {
            public CLI Parent { get; set; }

            private int OnExecute(CommandLineApplication app, IConsole console)
            {
                EGBenchLogger.WriteLine(console, "You must specify a subcommand.");
                console.WriteLine();
                app.ShowHelp();
                return 1;
            }

            [Command(Name = "start", Description = "Start generating load")]
            public class StartPublishCommand
            {
                public PublisherCLI Parent { get; set; }

                public CLI Root => this.Parent.Parent;

                [Option("-u|--topic-url", "REQUIRED. URL to which events should be posted to. Can specify multiple destinations like -u \"http://...\" -u \"http://...\" -u \"http://...\". Make sure number of URLs and number of topic names (-n) match up.", CommandOptionType.MultipleValue)]
                [Required]
                public string[] Addresses { get; set; }

                [Option("-n|--topic-name", "REQUIRED. String that should be used for stamping eventgrid event envelope's Topic field or cloud event envelope's source field. Can specify multiple values. Each value corresponds in order to the topic url.", CommandOptionType.MultipleValue)]
                [Required]
                public string[] TopicNames { get; set; }

                [Option("-s|--topic-schema", "Defaults to CloudEvent10. Possible values: EventGrid / CloudEvent10 / Custom. Specify the -d|--data-payload property for Custom topic schema.", CommandOptionType.SingleValue)]
                public string TopicSchema { get; set; } = "CloudEvent10";

                [Option("-d|--data-payload", "Specify the data payload when -s|--topic-schema=Custom. Either give inline json or a file path.", CommandOptionType.SingleValue)]
                public string DataPayload { get; set; }

                [Option("-p|--publishers", "Number of concurrent publishing \"threads\" per topic, defaults to 100. Each publisher sends to all the topic urls/names specified in -u / -n.", CommandOptionType.SingleValue)]
                public short ConcurrentPublishersCount { get; set; } = 100;

                [Option("-r|--rps-per-publisher", "Requests per second generated by each publish \"thread\", defaults to 1. Must be between 1 and 1000, inclusive.", CommandOptionType.SingleValue)]
                public short RequestsPerSecondPerPublisher { get; set; } = 1;

                [Option("-c|--max-concurrent-requests-per-publisher", "Max requests kept in flight by each publisher before waiting for older requests to end, defaults to 10.", CommandOptionType.SingleValue)]
                public short MaxConcurrentRequestsPerPublisher { get; set; } = 10;

                [Option("-e|--events-per-request", "Number of events in each request, defaults to 1.", CommandOptionType.SingleValue)]
                public ushort EventsPerRequest { get; set; } = 1;

                [Option("-b|--event-size-in-bytes", "Number of bytes per event, defaults to 1024, doesn't take effect if -s|--topic-schema==Custom. Total request payload size = 2 + (EventsPerRequest * (EventSizeInBytes + 1) - 1)", CommandOptionType.SingleValue)]
                public uint EventSizeInBytes { get; set; } = 1024;

                [Option("-t|--runtime-in-minutes", "Time after which the publisher auto-shuts down, defaults to 0 minutes. Set to 0 to run forever.", CommandOptionType.SingleValue)]
                public ushort RuntimeInMinutes { get; set; } = 0;

                [Option("-v|--protocol-version", "The protocol version to use, defaults to 1.1.", CommandOptionType.SingleValue)]
                public string HttpVersion { get; set; } = "1.1";

                [Option("|--skip-ssl-validation", "Skip SSL Server Certificate validation, defaults to false.", CommandOptionType.NoValue)]
                public bool SkipServerCertificateValidation { get; set; } = false;

                [Option("|--log-errors", "Log Status code, reason, and response content of all non-200 responses. Defaults to false.", CommandOptionType.NoValue)]
                public bool LogErrors { get; set; } = false;

                [Option("--total-requests", "Total number of requests to be made at the configured rate. When done, the publisher process will exit. Defaults to 0.", CommandOptionType.SingleValue)]
                public long TotalRequests { get; set; } = 0;

                public async Task<int> OnExecuteAsync(CommandLineApplication app, IConsole console)
                {
                    this.LogOptionValues(console);
                    this.Root.LogOptionValues(console);

                    if (this.ConcurrentPublishersCount < 1)
                    {
                        throw new InvalidOperationException($"-p|--publishers must be greater than 1.");
                    }

                    if (this.RequestsPerSecondPerPublisher < 1 || this.RequestsPerSecondPerPublisher > 1000)
                    {
                        throw new InvalidOperationException($"-r|--rps-per-publisher must be between 1 and 1000 inclusive");
                    }

                    if (this.Addresses.Length != this.TopicNames.Length ||
                        this.Addresses.Length < 1)
                    {
                        throw new InvalidOperationException($"-u|--topic-url and -n|--topic-name must have the same number of values (and have atleast one value).");
                    }

                    IPayloadCreator[] payloadCreators = this.TopicNames.Select<string, IPayloadCreator>(topicName =>
                        this.TopicSchema.ToUpperInvariant() switch
                        {
                            "EVENTGRID" => new EventGridPayloadCreator(topicName, this.EventSizeInBytes, this.EventsPerRequest, console),
                            "CLOUDEVENT10" => new CloudEvent10PayloadCreator(topicName, this.EventSizeInBytes, this.EventsPerRequest, console),
                            "CUSTOM" => new CustomPayloadCreator(this.DataPayload, this.EventsPerRequest, console),
                            _ => throw new NotImplementedException($"Unknown topic schema {this.TopicSchema}. Allowed schemas = EventGrid,CloudEvent10,Custom")
                        }).ToArray();

                    Metric.InitializePublisher(this.Root);
                    var tcs = new TaskCompletionSource<int>(TaskCreationOptions.RunContinuationsAsynchronously);
                    Action<int, Exception> exit = CreateExitHandler(tcs, console, this.RuntimeInMinutes);

                    PublishWorker[] workers = this.Addresses.Zip(payloadCreators).SelectMany(
                        kvp =>
                            Enumerable.Range(1, this.ConcurrentPublishersCount)
                            .Select(_ => new PublishWorker(this, kvp.First, kvp.Second, console, exit)))
                        .ToArray();

                    int timerIntervalMs = (int)(1000 / (double)this.RequestsPerSecondPerPublisher);
                    EGBenchLogger.WriteLine(console, $"{nameof(timerIntervalMs)}={timerIntervalMs} ms | Desired RPS={this.ConcurrentPublishersCount * this.RequestsPerSecondPerPublisher}");

                    long requestsQueued = 0;
                    long totalRequestsQueued = 0;
                    Timestamp lastLoggedTimestamp = Timestamp.Now;
                    Timestamp beginTimestamp = Timestamp.Now;
                    for (long iteration = 0; !(tcs.Task.IsCanceled | tcs.Task.IsFaulted | tcs.Task.IsCompletedSuccessfully); iteration++)
                    {
                        foreach (PublishWorker worker in workers)
                        {
                            if (worker.TryEnqueue(iteration))
                            {
                                requestsQueued++;
                                totalRequestsQueued++;
                            }

                            if (this.TotalRequests > 0 && totalRequestsQueued >= this.TotalRequests)
                            {
                                break;
                            }
                        }

                        if (lastLoggedTimestamp.ElapsedSeconds >= this.Parent.Parent.MetricsIntervalSeconds)
                        {
                            lastLoggedTimestamp = Timestamp.Now;
                            EGBenchLogger.WriteLine(console, $"Enqueued RPS in last {this.Parent.Parent.MetricsIntervalSeconds} seconds={requestsQueued / (float)this.Parent.Parent.MetricsIntervalSeconds:0.00f}.");
                            requestsQueued = 0;
                        }

                        if (this.TotalRequests > 0 && totalRequestsQueued >= this.TotalRequests)
                        {
                            await Task.WhenAll(workers.Select(async w =>
                            {
                                await Task.Yield();
                                await w.StopAsync();
                            }).ToArray());

                            EGBenchLogger.WriteLine($"Total Requests Made: {totalRequestsQueued}");

                            tcs.TrySetResult(0);
                            break;
                        }

                        Timestamp expectedTimestampNow = beginTimestamp + TimeSpan.FromMilliseconds(iteration * timerIntervalMs);
                        int lagMs = (int)Math.Ceiling((Timestamp.Now - expectedTimestampNow).TotalMilliseconds);
                        if (lagMs < timerIntervalMs)
                        {
                            await Task.Delay(timerIntervalMs - lagMs);
                        }
                        else
                        {
                            // don't sleep, just continue;
                        }
                    }

                    return await tcs.Task;
                }

                private static Action<int, Exception> CreateExitHandler(TaskCompletionSource<int> tcs, IConsole console, int runtimeInMinutes)
                {
                    if (runtimeInMinutes > 0)
                    {
                        _ = Task.Delay(TimeSpan.FromMinutes(runtimeInMinutes)).ContinueWith(
                            t =>
                            {
                                EGBenchLogger.WriteLine(console, $"--runtime-in-minutes ({runtimeInMinutes}) Minutes have passed, stopping the process.");
                                tcs.TrySetResult(0);
                            },
                            TaskScheduler.Default);
                    }

                    return ExitHandler;

                    void ExitHandler(int returnCode, Exception ex)
                    {
                        EGBenchLogger.WriteLine(console, $"{nameof(CreateExitHandler)} was invoked at stacktrace:\n{new StackTrace(true).ToString()}");

                        if (ex == null)
                        {
                            tcs.TrySetResult(returnCode);
                        }
                        else
                        {
                            tcs.TrySetException(ex);
                        }
                    }
                }
            }
        }
    }
}
